{"ast":null,"code":"const PUNCTUATION_LIST = ['.', ',', '!', '?', \"'\", '{', '}', '(', ')', '[', ']', '/'];\nconst spaceMatch = character => {\n  if (character === ' ') {\n    return true;\n  }\n};\nconst punctuationMatch = (idx, text) => {\n  const punctuationIdx = PUNCTUATION_LIST.indexOf(text[idx]);\n  if (punctuationIdx >= 0 && spaceMatch(text[idx + 1])) {\n    return true;\n  }\n};\nconst checkMatch = (idx, text, max, min) => {\n  if (idx < max && idx > min && punctuationMatch(idx, text)) {\n    return true;\n  }\n};\nconst trimText = (text, min = 80, ideal = 100, max = 200) => {\n  if (max < min || ideal > max || ideal < min) {\n    throw new Error('The minimum length must be less than the maximum, and the ideal must be between the minimum and maximum.');\n  }\n  if (text.length < ideal) {\n    return [text, ''];\n  }\n  let pointerOne = ideal;\n  let pointerTwo = ideal;\n  let firstSpace;\n  let resultIdx;\n  const setSpace = idx => {\n    if (spaceMatch(text[idx])) {\n      firstSpace = firstSpace || idx;\n    }\n  };\n  while (pointerOne < max || pointerTwo > min) {\n    if (checkMatch(pointerOne, text, max, min)) {\n      resultIdx = pointerOne + 1;\n      break;\n    } else if (checkMatch(pointerTwo, text, max, min)) {\n      resultIdx = pointerTwo + 1;\n      break;\n    } else {\n      setSpace(pointerOne);\n      setSpace(pointerTwo);\n    }\n    pointerOne += 1;\n    pointerTwo -= 1;\n  }\n  if (resultIdx === undefined) {\n    if (firstSpace && firstSpace >= min && firstSpace <= max) {\n      resultIdx = firstSpace;\n    } else if (ideal - min < max - ideal) {\n      resultIdx = min;\n    } else {\n      resultIdx = max;\n    }\n  }\n  return [text.slice(0, resultIdx), text.slice(resultIdx).trim()];\n};\nexport default trimText;","map":{"version":3,"names":["PUNCTUATION_LIST","spaceMatch","character","punctuationMatch","idx","text","punctuationIdx","indexOf","checkMatch","max","min","trimText","ideal","Error","length","pointerOne","pointerTwo","firstSpace","resultIdx","setSpace","undefined","slice","trim"],"sources":["/home/vmo/Desktop/demo/test/project-vtca/full-flim-vn/src/views/components/ReadMore/trimText.js"],"sourcesContent":["const PUNCTUATION_LIST = [\n  '.',\n  ',',\n  '!',\n  '?',\n  \"'\",\n  '{',\n  '}',\n  '(',\n  ')',\n  '[',\n  ']',\n  '/',\n];\n\nconst spaceMatch = (character) => {\n  if (character === ' ') {\n    return true;\n  }\n};\n\nconst punctuationMatch = (idx, text) => {\n  const punctuationIdx = PUNCTUATION_LIST.indexOf(text[idx]);\n  if (punctuationIdx >= 0 && spaceMatch(text[idx + 1])) {\n    return true;\n  }\n};\n\nconst checkMatch = (idx, text, max, min) => {\n  if (idx < max && idx > min && punctuationMatch(idx, text)) {\n    return true;\n  }\n};\n\nconst trimText = (text, min = 80, ideal = 100, max = 200) => {\n  if (max < min || ideal > max || ideal < min) {\n    throw new Error(\n      'The minimum length must be less than the maximum, and the ideal must be between the minimum and maximum.',\n    );\n  }\n\n  if (text.length < ideal) {\n    return [text, ''];\n  }\n\n  let pointerOne = ideal;\n  let pointerTwo = ideal;\n  let firstSpace;\n  let resultIdx;\n\n  const setSpace = (idx) => {\n    if (spaceMatch(text[idx])) {\n      firstSpace = firstSpace || idx;\n    }\n  };\n\n  while (pointerOne < max || pointerTwo > min) {\n    if (checkMatch(pointerOne, text, max, min)) {\n      resultIdx = pointerOne + 1;\n      break;\n    } else if (checkMatch(pointerTwo, text, max, min)) {\n      resultIdx = pointerTwo + 1;\n      break;\n    } else {\n      setSpace(pointerOne);\n      setSpace(pointerTwo);\n    }\n\n    pointerOne += 1;\n    pointerTwo -= 1;\n  }\n\n  if (resultIdx === undefined) {\n    if (firstSpace && firstSpace >= min && firstSpace <= max) {\n      resultIdx = firstSpace;\n    } else if (ideal - min < max - ideal) {\n      resultIdx = min;\n    } else {\n      resultIdx = max;\n    }\n  }\n\n  return [text.slice(0, resultIdx), text.slice(resultIdx).trim()];\n};\n\nexport default trimText;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}